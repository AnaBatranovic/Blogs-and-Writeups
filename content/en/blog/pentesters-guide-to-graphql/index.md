---
title: "A Pentesters Guide to Graphql"
description: "A guide for pentesting GraphQL."
lead: ""
date: 2023-11-26T13:25:09Z
lastmod: 2023-11-26T13:25:09Z
draft: true
weight: 50
images: ["pentesters-guide-to-graphql.png"]
contributors: []
---

GraphQL is everywhere nowadays. I often see it in my penetration testing engagements, as GraphQL offers various advantages over REST API. While it may not be a direct replacement for REST, it's certainly an evolution in API design. In contrast to REST APIs, which rely on sending data to an endpoint through HTTP requests (think `GET /item/1`), GraphQL allows clients to request specific data through queries. This means that users can only retrieve the data they need, reducing the risk of unnecessary information disclosure and therefore enhancing performance.

From a security perspective, the different approach to data retrieval in GraphQL also introduces a whole new range of vulnerabilities, in addition to classic issues that have always plagued REST APIs (you know the ones: SQLi, IDOR, Lack of Authorization, and the like). These GraphQL-specific vulnerabilities are often the result of poor implementation of GraphQL in the app itself, and can be easily fixed if you know what to look for. Despite this, almost every GraphQL application I've tested has had more than one high-risk vulnerability. As testers, it's our responsibility to ensure our clients are made aware of the security issues their applications face. This article is going to cover just that - the security issues affecting GraphQL as well as their solutions.

But before we get into the nitty gritty - what is GraphQL anyway?

# A Crash Course in GraphQL

GraphQL is an open source data query and manipulation language for APIs. It was developed by Facebook in 2012, and only became open source in 2015 when Facebook released the [specification](https://spec.graphql.org/) detailing all of its rules, design principles, and standard practices. Today it's maintained by the [GraphQL Foundation.](https://graphql.org/foundation/)

When setting up a server that handles GraphQL queries and mutations, developers will often use a framework. This means that GraphQL implementations will vary based on which framework was used, as many frameworks are not secure by default. Each framework also has security pitfalls researchers should be aware of. A great reference is the [GraphQL Threat Matrix](https://github.com/nicholasaleks/graphql-threat-matrix/) project, which shows what security features are supported by which GraphQL framework and whether they're enabled by default.

The schema is the core of GraphQL - it represents the type of data a client can query for. Once a schema is defined, clients can fetch information from it using specially crafted queries. Queries are defined by an operation type, a query name, a data structure and (optionally) arguments. There are three types of operations, which are defined at the beginning of the query:
- Queries are used for read-only operations, such as fetching data on a specific user.
- Mutations are used for data modification. An example would be mutation that allows the user to update their profile.
- Subscriptions are used for real-time communication between the server and client - this is done through a transport mechanism protocol such as a WebSocket.

Here's what a query looks like:

```
query GetDog {
	dogs(id: "1") {
		breed
		size
		age
	}
}
```

In this case, breed, size, and age are fields. Fields are attributes of objects that have a value. The argument specified for this query is one.

# Detecting & Fingerprinting GraphQL

We can detect whether an app is using GraphQL either by manually enumerating the web app we're testing or by specifically fuzzing for common GraphQL endpoints. There are wordlists such as [Daniel Miessler's GraphQL Discovery wordlist](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/graphql.txt) that are helpful for this:

```bash
$ ffuf -u http://localhost:5013/FUZZ -w graphql.txt -mc 400

        /'___\  /'___\           /'___\       
       /\ \__/ /\ \__/  __  __  /\ \__/       
       \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\      
        \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/      
         \ \_\   \ \_\  \ \____/  \ \_\       
          \/_/    \/_/   \/___/    \/_/       

       v2.0.0-dev
________________________________________________

 :: Method           : GET
 :: URL              : http://localhost:5013/FUZZ
 :: Wordlist         : FUZZ: ./graphql.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 400
________________________________________________

[Status: 400, Size: 53, Words: 4, Lines: 1, Duration: 10ms]
    * FUZZ: graphiql

[Status: 400, Size: 53, Words: 4, Lines: 1, Duration: 6ms]
    * FUZZ: graphql
```

Alternatively, we can use [graphw00f](https://github.com/dolevf/graphw00f), which automatically checks for the most common endpoints and gives us additional output, including the version of GraphQL currently implemented:

```bash
$ python3 graphw00f.py -f -d -t http://localhost:5013

                +-------------------+
                |     graphw00f     |
                +-------------------+
                  ***            ***
                **                  **
              **                      **
    +--------------+              +--------------+
    |    Node X    |              |    Node Y    |
    +--------------+              +--------------+
                  ***            ***
                     **        **
                       **    **
                    +------------+
                    |   Node Z   |
                    +------------+

                graphw00f - v1.1.12
          The fingerprinting tool for GraphQL
           Dolev Farhi <dolev@lethalbit.com>
  
[*] Checking http://localhost:5013/
[*] Checking http://localhost:5013/graphql
[!] Found GraphQL at http://localhost:5013/graphql
[*] Attempting to fingerprint...
[*] Discovered GraphQL Engine: (Graphene)
[!] Attack Surface Matrix: https://github.com/nicholasaleks/graphql-threat-matrix/blob/master/implementations/graphene.md                                                                    
[!] Technologies: Python                                                                                                                                                                     
[!] Homepage: https://graphene-python.org                                                                                                                                                    
[*] Completed.
```

Enumeration is key when testing. Always enumerate!

## How is GraphQL detected?

Tools that detect GraphQL use something known as the GraphQL “universal query”. This is a query to which GraphQL will always respond the same way, if it exists. The universal query looks like this:

```
query{__typename}
```

This works because the field `__typename` is included in every GraphQL specification. If GraphQL exists on the endpoint we sent this query to, the following string will always be included in the response:

```
{"data": {"__typename": "query"}}
```

# Testing GraphQL